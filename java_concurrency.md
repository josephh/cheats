# Java Concurrency
## Notes from Brian Goetz textbook
## The benefits of multiple threads
1. servers - a single threaded server will need to use non-blocking I/O if it to be able to handle multiple requests (rather than all requests stalling behind a blocked thread). Non-blocking, asynchronous I/O is complicated! So being able to create a new thread to handle each new request and use synchronous, blocking code in that individual thread is simpler.
1. frameworks - like RMI and servlets create new threads for each request - where threads are only synchronised at necessary points and allow simpler component development.
1. Better, more responsive GUIs - like AWT and Swing help.  Single-threaded applications that provide a GUi must either frequently poll for input events, or employ a 'main event loop'.  Where code called from the main event loop takes a long time to complete, the GUi appears to freeze. AWT and Swing avoid this by using an extra thread - an event dispatch thread - instead of an event loop.  Most GUi frameworks are still Single-threaded subsystems, so still use an event loop but it runs in its own dedicated thread, under the control of the GUi toolkit rather than the application.
### Safety - 'nothing bad ever happens'
Threads share the same memory address space - i.e. heap -  and run concurrently so can access or modify shared variables.  This is massively convenient! But also massively risky, since sequential code becomes potentially non-sequential and harder to reason about the state and behaviour of an application!  For a multithreaded program's behaviour to be predictable, access to shared variables must be properly coordinated to avoid threads interfering with each other - with mechanisms like Java synchronisation. But synchronisation obliges a compiler, hardware and runtime to take 'liberties' with timing and ordering of applications - like caching variables in registers or processor-local caches - to ensure program optimisation.  Understanding this can help to ensure program correctness.
### Liveness - 'something good eventually happens'
An inadvertent infinite loop is an example of a liveness problem that sequential and non-sequential problems both suffer from.  In multi-threaded apps, if one thread is waiting for another thread to release a resource but it never does so = liveness failure. Deadlock, livelock and starvation are all examples of liveness failures.
### performance hazards
multi-threaded, concurrent problems are intended to provide performance gains.  But multithreaded programs have overheads: a 'context switch' occurs each time a scheduler suspends an active thread temporarily to run another; it must save and restore execution context; lose locality; spend CPU time scheduling threads rather than running them...  
## What is a thread-safe class?
* 'Correctness' : means conforms to its specification
* 'Thread-safe classes' : means those that continue to behave correctly when accessed from multiple threads - regardless of any scheduling or interleaving of the execution of those threads by the runtime environment and with no additional synchronisation or other coordination needed on the part of the calling code.
Any Java class that runs in a single-threaded application can also run in a multi-threaded one.  If the class is correctly implemented against its spec - in terms of its invariants and postconditions - no sequence of operations that alter its state (reads/ writes of public fields, invocations of public methods) - should be able to violate those invariants and postconditions.
### Thread safety
1. Stateless classes are always threadsafe.  
1. Atomicity. 'UnsafeCountingFactorizerServlet' includes a private `count` variable (of type long).  The servlet's public `#service(...)` method increments `count` with a unary pre-increment e.g. `++count`.  Problem here is that the code is susceptible to 'lost updates' because `++` is not atomic (it is actually shorthand for _read-modify-write_).  With unlucky timing, thread _A_ can read the value of a shared piece of state just before thread _B_ writes a change to that same state back to memory - and hence _B_'s update to the shared state is lost when _A_ performs its own write.
